from typing import Any, Union, Callable, Sequence, overload, override
from polars import DataFrame, Expr, Series
import polars as pl
import numpy as np

Scalar = Union[int, float, str, bool, complex, np.number]
ExprInput = Union[str, Scalar, "Attr", Expr, "AttrComparison"]


class AttrComparison:
    attr: "Attr"
    column: str
    op: Callable
    other: ExprInput
    
    def __init__(self, attr: "Attr", op: Callable, other: ExprInput) -> None: ...
    def __repr__(self) -> str: ...
    def to_attr(self) -> "Attr": ...
    def __getattr__(self, attr: str) -> Any: ...
    def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -> "Attr": ...
    
    # Binary operators
    def __add__(self, other: ExprInput) -> "Attr": ...
    def __sub__(self, other: ExprInput) -> "Attr": ...
    def __mul__(self, other: ExprInput) -> "Attr": ...
    def __truediv__(self, other: ExprInput) -> "Attr": ...
    def __floordiv__(self, other: ExprInput) -> "Attr": ...
    def __mod__(self, other: ExprInput) -> "Attr": ...
    def __pow__(self, other: ExprInput) -> "Attr": ...
    def __and__(self, other: ExprInput) -> "Attr": ...
    def __or__(self, other: ExprInput) -> "Attr": ...
    def __xor__(self, other: ExprInput) -> "Attr": ...
    
    # Reverse operators
    def __radd__(self, other: Scalar) -> "Attr": ...
    def __rsub__(self, other: Scalar) -> "Attr": ...
    def __rmul__(self, other: Scalar) -> "Attr": ...
    def __rtruediv__(self, other: Scalar) -> "Attr": ...
    def __rfloordiv__(self, other: Scalar) -> "Attr": ...
    def __rmod__(self, other: Scalar) -> "Attr": ...
    def __rpow__(self, other: Scalar) -> "Attr": ...
    def __rand__(self, other: Scalar) -> "Attr": ...
    def __ror__(self, other: Scalar) -> "Attr": ...
    def __rxor__(self, other: Scalar) -> "Attr": ...
    
    # Comparison operators (always return Attr)
    def __eq__(self, other: ExprInput) -> "Attr": ...
    def __ne__(self, other: ExprInput) -> "Attr": ...
    def __lt__(self, other: ExprInput) -> "Attr": ...
    def __le__(self, other: ExprInput) -> "Attr": ...
    def __gt__(self, other: ExprInput) -> "Attr": ...
    def __ge__(self, other: ExprInput) -> "Attr": ...


class Attr:
    expr: Expr
    
    def __init__(self, value: ExprInput) -> None: ...
    def _wrap(self, expr: Union[Expr, Any]) -> Union["Attr", Any]: ...
    def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -> "Attr": ...
    def _delegate_comparison_operator(self, other: Any, op: Callable, reverse: bool = False) -> Union["AttrComparison", "Attr"]: ...
    def alias(self, name: str) -> "Attr": ...
    def evaluate(self, df: DataFrame) -> Series: ...
    @property
    def columns(self) -> list[str]: ...
    @property
    def inf_exprs(self) -> list["Attr"]: ...
    @property
    def neg_inf_exprs(self) -> list["Attr"]: ...
    @property
    def expr_columns(self) -> list[str]: ...
    @property
    def inf_columns(self) -> list[str]: ...
    @property
    def neg_inf_columns(self) -> list[str]: ...
    def has_inf(self) -> bool: ...
    def has_pos_inf(self) -> bool: ...
    def has_neg_inf(self) -> bool: ...
    def __invert__(self) -> "Attr": ...
    def __neg__(self) -> "Attr": ...
    def __pos__(self) -> "Attr": ...
    def __abs__(self) -> "Attr": ...
    def __getattr__(self, attr: str) -> Any: ...
    def __repr__(self) -> str: ...
    
    # Binary operators
    def __add__(self, other: ExprInput) -> "Attr": ...
    def __sub__(self, other: ExprInput) -> "Attr": ...
    def __mul__(self, other: ExprInput) -> "Attr": ...
    def __truediv__(self, other: ExprInput) -> "Attr": ...
    def __floordiv__(self, other: ExprInput) -> "Attr": ...
    def __mod__(self, other: ExprInput) -> "Attr": ...
    def __pow__(self, other: ExprInput) -> "Attr": ...
    def __and__(self, other: ExprInput) -> "Attr": ...
    def __or__(self, other: ExprInput) -> "Attr": ...
    def __xor__(self, other: ExprInput) -> "Attr": ...
    
    # Reverse operators
    def __radd__(self, other: Scalar) -> "Attr": ...
    def __rsub__(self, other: Scalar) -> "Attr": ...
    def __rmul__(self, other: Scalar) -> "Attr": ...
    def __rtruediv__(self, other: Scalar) -> "Attr": ...
    def __rfloordiv__(self, other: Scalar) -> "Attr": ...
    def __rmod__(self, other: Scalar) -> "Attr": ...
    def __rpow__(self, other: Scalar) -> "Attr": ...
    def __rand__(self, other: Scalar) -> "Attr": ...
    def __ror__(self, other: Scalar) -> "Attr": ...
    def __rxor__(self, other: Scalar) -> "Attr": ...
    
    # Comparison operators with overloads
    @overload
    def __eq__(self, other: "Attr") -> "Attr": ...
    @overload
    def __eq__(self, other: Scalar) -> "AttrComparison": ...
    
    @overload
    def __ne__(self, other: "Attr") -> "Attr": ...
    @overload
    def __ne__(self, other: Scalar) -> "AttrComparison": ...
    
    @overload
    def __lt__(self, other: "Attr") -> "Attr": ...
    @overload
    def __lt__(self, other: Scalar) -> "AttrComparison": ...
    
    @overload
    def __le__(self, other: "Attr") -> "Attr": ...
    @overload
    def __le__(self, other: Scalar) -> "AttrComparison": ...
    
    @overload
    def __gt__(self, other: "Attr") -> "Attr": ...
    @overload
    def __gt__(self, other: Scalar) -> "AttrComparison": ...
    
    @overload
    def __ge__(self, other: "Attr") -> "Attr": ...
    @overload
    def __ge__(self, other: Scalar) -> "AttrComparison": ...


class NodeAttr(Attr):
    pass


class EdgeAttr(Attr):
    pass


def split_attr_comps(attr_comps: Sequence[AttrComparison]) -> tuple[list[AttrComparison], list[AttrComparison]]: ...

def attr_comps_to_strs(attr_comps: list[AttrComparison]) -> list[str]: ...

def polars_reduce_attr_comps(df: pl.DataFrame, attr_comps: list[AttrComparison]) -> pl.Expr: ... 